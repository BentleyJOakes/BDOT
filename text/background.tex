\section{Background}

\subsection{Causal Block Diagrams}
Causal block diagrams are typed graphs, where each vertex has input and output ports. Data, such as scalars and vectors passs along data lines between ports. Each block then performs an operation n the inut dta and outputs it.

\subsection{Simulink}

Simulink is fun. I love Simulink.

Simulink is a tool created by Mathworks to aid in the development of software. It provides a visual environment to create causal block diagram-like models, which are then generated into C code. This code is then the implementation of the model.


\subsection{Compiler Optimization Techniques}

Code is compiled to a lower level, such as C-code to machine code, or Java code to Java bytecode.

While performing this translation step, code compilers will also do a number of optimizations to remove redundant code.

We aim to identify optimizations that are relevant to the causal block diagram domain and measure their impact.




\subsubsection{Flow Analysis Steps}

An important tool for these optimizations is flow analysis, As code can be represented in control flow blocks, information can be thought of to flow between these blocks.

This allows compilers to identify variables and lines of code that can be removed, for example.

We take Laurie's six-step process for flow analysis for code compliation here.

\begin{enumerate}
\item Define the approximations to build, as well as a partial ordering for these approximations
\begin{itemize}
\item Such as sets of variable for live variable analysis. The ordering is based on set inclusion.
\end{itemize}

\item State the problem precisely
\begin{itemize}
\item Usually stated for program point p, and concerning paths to and from the start and end blocks
\item Such as which variables have been used above this line of code.
\end{itemize}

\item Is the analysis a forwards or backwards analysis
\begin{itemize}
\item Does the analysis start at the beginning block and move forwards, or the end and move backwards through the topological sort
\end{itemize}

\item Given an approximation for two parent blocks, how are the approximations merged
\begin{itemize}
\item Usually intersection or union
\end{itemize}

\item Write the flow equations for each statement in the language
\begin{itemize}
\item How does each statement affect the approximation for that statement
\end{itemize}

\item State the starting approximations
\begin{itemize}
\item What is the approximation at the start of the analysis
\item If there are loops in the control-flow graph, what assumption is made about the looping approximation
\end{itemize}

\end{enumerate}


\subsubsection{Applicability of Flow Analysis to Causal-Block Diagrams}

It is important to note the distinctions between the standard code compliation control-flow graph and a causal-block diagram. For example, in a control-flow graph, there is a distinct start block. In a causal-block diagram, any block without a parent is executed in some order. This means that scheduling of the causal-blocks must be taken into consideration.

In Simulink, there is also the concept of subsystems, which are not quite analogous to functions. As well, there is the concept of sampling, which means that there are timing dependencies and considerations when defining optimizations.

\subsection{Model Transformations}

In order to perform the optimizations on the model itself, we use model transformations. These transformations are composed of a number of rules, which each have a LHS and a RHS. THe LHS matches the elements within with elements in the model. The elements are then replaced with the lements in the RHS of the rule. There are also pivots.
